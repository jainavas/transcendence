<!doctype html>
<html lang="es">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>BabylonJS con UI Integrada</title>

    <!-- Babylon.js y dependencias -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>

    <!-- CSS para pantalla completa y UI -->
    <style>
        html, body {
            width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #renderCanvas {
            width: 100%; height: 100%; display: block;
            touch-action: none;
            background-color: #000;
        }
        #uiContainer {
            position: absolute; top: 10px; left: 0;
            width: 100%; z-index: 10; pointer-events: none;
            display: flex; justify-content: space-between; align-items: center;
            padding: 2 1rem;
        }
        #uiContainer > * { pointer-events: auto; }
        #scoreDisplay {
            background: rgba(0,0,0,0.5); color: #fff;
            padding: 0.5rem 1rem; border-radius: 4px;
        }
        #gameOver {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8); color: #fff;
            padding: 2rem; border-radius: 8px;
            text-align: center; z-index: 20;
            display: none;
        }
        #gameOver button {
            display: block; width: 100%; margin: 0.5rem 0;
            padding: 0.75rem; border: none; border-radius: 4px;
            font-size: 1rem; cursor: pointer;
        }
        .btn-blue { background: #007bff; color: #fff; }
        .btn-blue:hover { background: #0056b3; }
        .btn-green { background: #28a745; color: #fff; }
        .btn-green:hover { background: #218838; }
        .btn-gray { background: #6c757d; color: #fff; }
        .btn-gray:hover { background: #5a6268; }

        /* Estilos mejorados para botones */
        .game-button {
            border: none;
            padding: 8px 14px;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.9rem;
            letter-spacing: 0.5px;
            margin-left: 10px;
        }
        
        .btn-blue {
            background: linear-gradient(to bottom, #3498db, #2980b9);
            color: #fff;
            border: 1px solid #2980b9;
        }
        
        .btn-blue:hover {
            background: linear-gradient(to bottom, #2980b9, #2573a7);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
        }
        
        .btn-orange {
            background: linear-gradient(to bottom, #e67e22, #d35400);
            color: #fff;
            border: 1px solid #d35400;
        }
        
        .btn-orange:hover {
            background: linear-gradient(to bottom, #d35400, #c04e00);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
        }
        
        #resetCameraButton {
            display: none; /* Oculto por defecto */
			background: linear-gradient(to bottom, #2ecc71, #27ae60);
			color: #fff;
			border: 1px solid #27ae60;
        }
        
        #resetCameraButton:hover {
            background: linear-gradient(to bottom, #27ae60, #1e8449);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
        }
        
        /* Contenedor de botones */
        .buttons-container {
            display: flex;
            align-items: center;
        }
    </style>
</head>
<body>
    <!-- Canvas 3D -->
    <canvas id="renderCanvas"></canvas>

    <!-- UI Superior -->
    <div id="uiContainer">
        <div id="scoreDisplay">Puntuación: <span id="score">0</span></div>
        <div class="buttons-container">
            <button id="resetCameraButton" class="game-button btn-orange">
                <i>↺</i> Resetear cámara
            </button>
            <button id="backButton" class="game-button btn-blue">
                <i>←</i> Volver al Dashboard
            </button>
        </div>
    </div>

    <!-- Pantalla Game Over -->
    <div id="gameOver">
        <h2>¡Juego terminado!</h2>
        <p>Tu puntuación: <span id="finalScore">0</span></p>
        <button id="playAgainButton" class="btn-green">Jugar de nuevo</button>
        <button id="saveToDashboardButton" class="btn-blue">Guardar puntuación</button>
        <button id="returnToDashboardButton" class="btn-gray">Volver al Dashboard</button>
    </div>

    <script>
        // Variables globales
        var canvas = document.getElementById("renderCanvas");
        var engine = new BABYLON.Engine(canvas, true);
        var scene;
        var score = 0;

        // Inicia bucle de render
        var startRenderLoop = function () {
            engine.runRenderLoop(function () {
                if (scene && scene.activeCamera) {
                    scene.render();
                }
            });
        };

        // Clase de creación de escena Babylon
        class Playground {
            static CreateScene(engine, canvas) {
                var scene = new BABYLON.Scene(engine);

                // Cámara orbital cenital
                var camera = new BABYLON.ArcRotateCamera(
                    "camera1",
                    -Math.PI/2,
                    Math.PI/4.5,
                    2.3,
                    new BABYLON.Vector3(0,1,0),
                    scene
                );
                camera.attachControl(canvas, true);
				camera.lowerRadiusLimit = 2.3;
				camera.upperRadiusLimit = 2.3;
				canvas.focus();
				var defaultPosition = {
					alpha: -Math.PI / 2,
					beta: Math.PI / 4.5,
					radius: 2.3
				};

				var resetCameraButton = document.getElementById('resetCameraButton');

				// Función para comprobar si la cámara se ha movido
				function checkCameraPosition() {
					var epsilon = 0.05; // Tolerancia para comparaciones
					
					// Verificar si el usuario ha movido la cámara significativamente
					var alphaDiff = Math.abs(camera.alpha - defaultPosition.alpha);
					var betaDiff = Math.abs(camera.beta - defaultPosition.beta);
					var radiusDiff = Math.abs(camera.radius - defaultPosition.radius);
					
					// Determinar si la cámara está fuera de posición
					var camaraMovida = (alphaDiff > epsilon || betaDiff > epsilon || radiusDiff > epsilon);
					
					// Mostrar u ocultar el botón según la posición de la cámara
					resetCameraButton.style.display = camaraMovida ? 'flex' : 'none';
				}

				// Función para resetear la cámara
				function resetCamera() {
					camera.alpha = defaultPosition.alpha;
					camera.beta = defaultPosition.beta;
					camera.radius = defaultPosition.radius;
					// Actualizar visibilidad del botón
					checkCameraPosition();
				}
				
				// Hacer función resetCamera accesible globalmente
				window.resetCamera = resetCamera;
				
				// Detectar movimiento de la cámara
				camera.onViewMatrixChangedObservable.add(function() {
					checkCameraPosition();
				});
				
				// Comprobar posición inicial
				checkCameraPosition();

                // Luz
                var light = new BABYLON.HemisphericLight(
                    "light1",
                    new BABYLON.Vector3(0,1,0),
                    scene
                );
                light.intensity = 0.8;
				
				const hdrTexture = new BABYLON.HDRCubeTexture("textures/fondo.hdr", scene, 512, false, true, false, true);
				scene.environmentTexture = hdrTexture;
				scene.createDefaultSkybox(hdrTexture, true, 1000);
				
                // Material madera PBR
				var woodMat = new BABYLON.PBRMaterial("woodMat", scene);
				woodMat.albedoTexture = new BABYLON.Texture(
					"https://dl.polyhaven.org/file/ph-assets/Textures/jpg/1k/plywood/plywood_diff_1k.jpg",
					scene
				);
				woodMat.roughness = 1;  // completamente mate
				woodMat.metallic = 0;
				// Material metal PBR
				var metalMat = new BABYLON.PBRMaterial("metalMat", scene);
				metalMat.albedoTexture = new BABYLON.Texture(
					"https://dl.polyhaven.org/file/ph-assets/Textures/jpg/1k/rusty_metal_04/rusty_metal_04_diff_1k.jpg",
					scene
				);
				metalMat.roughness = 0.8; // algo de brillo metálico
				metalMat.metallic = 1;				

                // Material Concrete para las patas
                var concreteMat = new BABYLON.PBRMaterial("concreteMat", scene);
                concreteMat.albedoTexture = new BABYLON.Texture("textures/concrete_0014_color_2k.jpg", scene);
                concreteMat.bumpTexture = new BABYLON.Texture("textures/concrete_0014_normal_opengl_2k.png", scene);
                concreteMat.ambientTexture = new BABYLON.Texture("textures/concrete_0014_ao_2k.jpg", scene);
                concreteMat.roughness = 0.9;
                concreteMat.metallic = 0.1;
                // Usar parallax para dar profundidad
                concreteMat.parallaxTexture = new BABYLON.Texture("textures/concrete_0014_height_2k.png", scene);
                concreteMat.useParallax = true;
                concreteMat.useParallaxOcclusion = true;
                concreteMat.parallaxScaleBias = 0.08;

                // Material Aerial para la tabla de la mesa
                var aerialMat = new BABYLON.PBRMaterial("aerialMat", scene);
                aerialMat.albedoTexture = new BABYLON.Texture("textures/aerial_rocks_02_diff_2k.jpg", scene);
                aerialMat.bumpTexture = new BABYLON.Texture("textures/aerial_rocks_02_nor_gl_2k.png", scene);
                aerialMat.metallicTexture = new BABYLON.Texture("textures/aerial_rocks_02_rough_2k.jpg", scene);
                aerialMat.useRoughnessFromMetallicTextureAlpha = true;
                aerialMat.metallic = 0.2;
                aerialMat.roughness = 0.7;
                // Parallax
                aerialMat.parallaxTexture = new BABYLON.Texture("textures/aerial_rocks_02_disp_2k.png", scene);
                aerialMat.useParallax = true;
                aerialMat.useParallaxOcclusion = true;
                aerialMat.parallaxScaleBias = 0.1;

				// Ajuste de definicion de las texturas
				const scale = 2; // o prueba con 6 u 8 para más detalle

				concreteMat.albedoTexture.uScale = scale;
				concreteMat.albedoTexture.vScale = scale;
				concreteMat.bumpTexture.uScale = scale;
				concreteMat.bumpTexture.vScale = scale;
				concreteMat.ambientTexture.uScale = scale;
				concreteMat.ambientTexture.vScale = scale;
				concreteMat.parallaxTexture.uScale = scale;
				concreteMat.parallaxTexture.vScale = scale;

				aerialMat.albedoTexture.uScale = scale;
				aerialMat.albedoTexture.vScale = scale;
				aerialMat.bumpTexture.uScale = scale;
				aerialMat.bumpTexture.vScale = scale;
				aerialMat.metallicTexture.uScale = scale;
				aerialMat.metallicTexture.vScale = scale;
				aerialMat.parallaxTexture.uScale = scale;
				aerialMat.parallaxTexture.vScale = scale;

				concreteMat.albedoTexture.anisotropicFilteringLevel = 16;
				aerialMat.albedoTexture.anisotropicFilteringLevel = 16;

                // Material de bloques medievales para el borde de la mesa
                var marbleMat = new BABYLON.PBRMaterial("marbleMat", scene);
                marbleMat.albedoTexture = new BABYLON.Texture("textures/medieval_blocks_06_diff_2k.jpg", scene);
                marbleMat.bumpTexture = new BABYLON.Texture("textures/medieval_blocks_06_nor_gl_2k.png", scene);
                marbleMat.metallicTexture = new BABYLON.Texture("textures/medieval_blocks_06_rough_2k.jpg", scene);
                marbleMat.useRoughnessFromMetallicTextureAlpha = true;
                marbleMat.metallic = 0.1;
                marbleMat.roughness = 0.6; // Ajustado para bloques de piedra
                marbleMat.parallaxTexture = new BABYLON.Texture("textures/medieval_blocks_06_disp_2k.png", scene);
                marbleMat.useParallax = true;
                marbleMat.useParallaxOcclusion = true;
                marbleMat.parallaxScaleBias = 0.08;

                // Ajustes adicionales para mejor calidad visual
                marbleMat.albedoTexture.anisotropicFilteringLevel = 16;
                marbleMat.albedoTexture.wrapU = BABYLON.Texture.WRAP_ADDRESSMODE;
                marbleMat.albedoTexture.wrapV = BABYLON.Texture.WRAP_ADDRESSMODE;

                // Aplicar el mismo modo de wrap a las otras texturas
                marbleMat.bumpTexture.wrapU = BABYLON.Texture.WRAP_ADDRESSMODE;
                marbleMat.bumpTexture.wrapV = BABYLON.Texture.WRAP_ADDRESSMODE;
                marbleMat.metallicTexture.wrapU = BABYLON.Texture.WRAP_ADDRESSMODE;
                marbleMat.metallicTexture.wrapV = BABYLON.Texture.WRAP_ADDRESSMODE;
                marbleMat.parallaxTexture.wrapU = BABYLON.Texture.WRAP_ADDRESSMODE;
                marbleMat.parallaxTexture.wrapV = BABYLON.Texture.WRAP_ADDRESSMODE;

				const personajes = [
				{
					nombre: "Vaca",
					ruta: "textures/vaca/",
					archivo: "scene.gltf",
					posicion: new BABYLON.Vector3(2.3, 0, 0),
					escala: new BABYLON.Vector3(0.6, 0.6, 0.6),
					rotacion: new BABYLON.Vector3(0, -Math.PI / 2, Math.PI)
				},
				{
					nombre: "Trucha",
					ruta: "textures/pez/",
					archivo: "pez.gltf",
					posicion: new BABYLON.Vector3(1.5, 0.85, 0),
					escala: new BABYLON.Vector3(0.5, 0.5, 0.5),
					rotacion: new BABYLON.Vector3(0, Math.PI / 2, Math.PI)
				}
				];

				function cargarPersonajeEnLado({ 
					personajeConfig, 
					lado = "izquierda", 
					escena, 
					callback 
					}) {
					const nombreContenedor = `${personajeConfig.nombre}_${lado}`;
					BABYLON.SceneLoader.ImportMesh(
						null,
						personajeConfig.ruta,
						personajeConfig.archivo,
						escena,
						function (meshes, particleSystems, skeletons, animationGroups) {
						// Eliminar contenedor anterior si existe
						const anterior = escena.getNodeByName(nombreContenedor);
						if (anterior) anterior.dispose();

						const contenedor = new BABYLON.TransformNode(nombreContenedor, escena);

						meshes.forEach(mesh => {
							mesh.setParent(contenedor);
							if (mesh.rotationQuaternion) mesh.rotationQuaternion = null;
							});
							
							contenedor.scaling = personajeConfig.escala.clone();
							
							// Crear posición correctamente según el lado
							let posicion = personajeConfig.posicion.clone();
							if (lado === "izquierda") {
								posicion.x = posicion.x * -1; // Invertir X para el lado izquierdo
							}
							contenedor.position = posicion; // Asignar la posición modificada
							
							// Configurar rotación según el lado
							let rotacion = personajeConfig.rotacion.clone();
							if (lado === "derecha") {
								rotacion.y = Math.PI * 2 - rotacion.y; // Invertir rotación Y para el lado derecho
							}
							contenedor.rotation = rotacion;

						if (callback) {
							callback({ contenedor, meshes, skeletons, animationGroups });
						}
						}
					);
					}

				cargarPersonajeEnLado({
					personajeConfig: personajes[0],
					lado: "derecha",
					escena: scene,
					callback: function ({ animationGroups }) {
						const idle = animationGroups[0];
						if (idle) idle.start(true);
					}
					});

				cargarPersonajeEnLado({
					personajeConfig: personajes[1],
					lado: "izquierda",
					escena: scene,
					callback: function ({ animationGroups }) {
						const idle = animationGroups[0];
						if (idle) idle.start(true);
					}
					});
				// Agregar esto cerca del inicio de CreateScene
				scene.audioEnabled = true;
                
                // Crear el suelo blanco básico
                var groundMaterial = new BABYLON.PBRMaterial("groundMaterial", scene);
                groundMaterial.albedoColor = new BABYLON.Color3(0.95, 0.95, 0.95); // Color blanco ligeramente grisáceo
                groundMaterial.roughness = 0.9; // Muy mate, sin brillo
                groundMaterial.metallic = 0.1; // Casi nada de aspecto metálico

                // Tamaño suficiente para abarcar la mesa y los personajes 
                // (ancho 6 unidades para cubrir desde la vaca hasta más allá de la trucha)
                var ground = BABYLON.MeshBuilder.CreateGround(
                    "ground",
                    { width: 6, height: 3.5, subdivisions: 2 },  // Ancho suficiente para cubrir los personajes
                    scene
                );
                ground.position.y = -0.01; // Ligeramente bajo la posición 0 para evitar z-fighting
                ground.receiveShadows = true; // Para recibir sombras si las implementas

                ground.material = groundMaterial;

                // Si no tienes una textura de rejilla, puedes comentar las 5 líneas anteriores
                // y usar solo el material con el color blanco básico

                // Mesa: tablero y patas
                // Definir la nueva altura base de la mesa (más baja)
                const mesaAltura = 0.6; // Reducido de 1.0 a 0.6
                
				// Mesa
				var tableTop = BABYLON.MeshBuilder.CreateBox(
                    "tableTop", {width:2, depth:1, height:0.1}, scene
                );
                tableTop.position.y = mesaAltura;
                tableTop.material = aerialMat;
                
                var pala1 = BABYLON.MeshBuilder.CreateBox(
                    "pala1", {width:0.1, depth:0.25, height:0.05}, scene
                );
                pala1.position = new BABYLON.Vector3(
                    0.95,
                    tableTop.position.y + 0.05 + tableTop.getBoundingInfo().boundingBox.extendSize.y,
                    0 // Posición Z inicial centrada
                );
                pala1.material = metalMat;

                var pala2 = BABYLON.MeshBuilder.CreateBox(
                    "pala2", {width:0.1, depth:0.25, height:0.05}, scene
                );
                pala2.position = new BABYLON.Vector3(
                    -0.95,
                    tableTop.position.y + 0.05 + tableTop.getBoundingInfo().boundingBox.extendSize.y,
                    0 // Posición Z inicial centrada
                );
                pala2.material = metalMat;

                var bola = BABYLON.MeshBuilder.CreateSphere(
                    "bola", {diameter: 0.1}, scene
                );
                bola.position.y = tableTop.position.y + 0.05 + tableTop.getBoundingInfo().boundingBox.extendSize.y;
                bola.material = metalMat;

                // Ajustar las patas para que sean proporcionalmente más cortas
                var legParams = { diameter: 0.1, height: mesaAltura }; // Altura ajustada
                
                // Calcular correctamente la posición Y de las patas
                // La posición Y debe ser la mitad de la altura de la pata, para que su parte superior
                // coincida exactamente con la parte inferior del tablero
                const legY = legParams.height / 2;
                
                [ [0.9, legY, 0.4], [-0.9, legY, 0.4], [0.9, legY, -0.4], [-0.9, legY, -0.4] ]
                .forEach(function(pos,i) {
                    var leg = BABYLON.MeshBuilder.CreateCylinder(
                        "leg"+i, legParams, scene
                    );
                    leg.position = new BABYLON.Vector3(pos[0], pos[1], pos[2]);
                    leg.material = concreteMat;
                });

                // Crear el borde de la mesa
                const borderHeight = 0.10; // Altura del borde lateral
                const borderThickness = 0.05; // Grosor del borde
                const borderOffset = 0.05; // Cuánto sobresale por encima

                // Borde frontal
                var frontBorder = BABYLON.MeshBuilder.CreateBox(
                    "frontBorder", {width: 2.1, depth: borderThickness, height: borderHeight}, scene
                );
                frontBorder.position.y = tableTop.position.y + tableTop.getBoundingInfo().boundingBox.extendSize.y + (borderHeight/2 - borderOffset);
                frontBorder.position.z = 0.5 + borderThickness/2;
                frontBorder.material = marbleMat;

                // Borde trasero
                var backBorder = BABYLON.MeshBuilder.CreateBox(
                    "backBorder", {width: 2.1, depth: borderThickness, height: borderHeight}, scene
                );
                backBorder.position.y = tableTop.position.y + tableTop.getBoundingInfo().boundingBox.extendSize.y + (borderHeight/2 - borderOffset);
                backBorder.position.z = -0.5 - borderThickness/2;
                backBorder.material = marbleMat;

                // Borde izquierdo
                var leftBorder = BABYLON.MeshBuilder.CreateBox(
                    "leftBorder", {width: borderThickness - 0.01, depth: 1.09, height: borderHeight - borderOffset}, scene
                );
                leftBorder.position.y = tableTop.position.y + tableTop.getBoundingInfo().boundingBox.extendSize.y + (borderHeight/2 - borderOffset);
                leftBorder.position.x = -1 - borderThickness/2;
                leftBorder.material = marbleMat;

                // Borde derecho
                var rightBorder = BABYLON.MeshBuilder.CreateBox(
                    "rightBorder", {width: borderThickness - 0.01, depth: 1.09, height: borderHeight - borderOffset}, scene
                );
                rightBorder.position.y = tableTop.position.y + tableTop.getBoundingInfo().boundingBox.extendSize.y + (borderHeight/2 - borderOffset);
                rightBorder.position.x = 1 + borderThickness/2;
                rightBorder.material = marbleMat;

                // Aplicar escala a las texturas de mármol/bloques medievales diferenciada según la orientación
                // Para los bordes frontal y trasero (largos y estrechos en anchura)
                frontBorder.material = marbleMat.clone("frontBorderMat");
                backBorder.material = marbleMat.clone("backBorderMat");

                // Para los bordes laterales (largos y estrechos en profundidad)
                leftBorder.material = marbleMat.clone("leftBorderMat");
                rightBorder.material = marbleMat.clone("rightBorderMat");

                // Método alternativo y más limpio
                function configureClonedMaterial(original, clone, uScale, vScale) {
                    // Clonar texturas para evitar afectar al material original
                    clone.albedoTexture = original.albedoTexture.clone();
                    clone.bumpTexture = original.bumpTexture.clone();
                    clone.metallicTexture = original.metallicTexture.clone();
                    clone.parallaxTexture = original.parallaxTexture.clone();
                    
                    // Configurar escalas
                    clone.albedoTexture.uScale = uScale;
                    clone.albedoTexture.vScale = vScale;
                    clone.bumpTexture.uScale = uScale;
                    clone.bumpTexture.vScale = vScale;
                    clone.metallicTexture.uScale = uScale;
                    clone.metallicTexture.vScale = vScale;
                    clone.parallaxTexture.uScale = uScale;
                    clone.parallaxTexture.vScale = vScale;
                }

                // Usar la función
                configureClonedMaterial(marbleMat, frontBorder.material, 16, 0.5);
                configureClonedMaterial(marbleMat, backBorder.material, 16, 0.5);
                configureClonedMaterial(marbleMat, leftBorder.material, 0.5, 16);
                configureClonedMaterial(marbleMat, rightBorder.material, 0.5, 16);

				 // 1. Primero desactivar las teclas de flecha para la cámara
				camera.keysUp = [];    // Tecla arriba (normalmente es 38)
				camera.keysDown = [];  // Tecla abajo (normalmente es 40)
				camera.keysLeft = [];  // Tecla izquierda (normalmente es 37)
				camera.keysRight = []; // Tecla derecha (normalmente es 39)

				const paddleSpeed = 0.01; // Aumentado de 0.0001 a 0.01 (100 veces más rápido)
				const tableHalfDepth = 0.5;
                // Reemplace el manejo de teclado existente con este enfoque
				var keysPressed = {};
				 // Modificar el listener de teclado para ignorar teclas modificadoras
				window.addEventListener("keydown", function(e) {
					// Solo registrar teclas que nos interesan para el juego
					if (e.key === 'a' || e.key === 'd' || 
						e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
						keysPressed[e.key] = true;
						e.preventDefault(); // Prevenir comportamiento predeterminado
					}
				});

				window.addEventListener("keyup", function(e) {
					// Solo registrar teclas que nos interesan para el juego
					if (e.key === 'a' || e.key === 'd' || 
						e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
						keysPressed[e.key] = false;
					}
				});

				// Movimiento de la bola
				let ballDirection = new BABYLON.Vector3(0.02, 0 , 0); // velocidad inicial
				let ballSpeed = 0.02;
				let gameActive = true;

				scene.onBeforeRenderObservable.clear(); // Elimina observadores existentes

				// 3. Crea un único observador para todo el juego
				scene.onBeforeRenderObservable.add(() => {
					if (!gameActive) return;
					
					// Movimiento de la bola
					bola.position.addInPlace(ballDirection);
					
					// Movimiento de las palas
					if (keysPressed['a']) pala2.position.z -= paddleSpeed;
					if (keysPressed['d']) pala2.position.z += paddleSpeed;
					if (keysPressed['ArrowLeft']) pala1.position.z -= paddleSpeed;
					if (keysPressed['ArrowRight']) pala1.position.z += paddleSpeed;
					
					// Límites de las palas con el tablero
					const paddlePadding = 0.01;
					if (pala1.position.z > tableHalfDepth)
						pala1.position.z = tableHalfDepth - paddlePadding;
					if (pala1.position.z < -tableHalfDepth)
						pala1.position.z = -tableHalfDepth + paddlePadding;
					
					if (pala2.position.z > tableHalfDepth)
						pala2.position.z = tableHalfDepth - paddlePadding;
					if (pala2.position.z < -tableHalfDepth)
						pala2.position.z = -tableHalfDepth + paddlePadding;
					
					// Rebote con bordes laterales de la mesa (más preciso)
					console.log(tableHalfDepth, bola.position.z);
					if (bola.position.z + 0.05 > tableHalfDepth || 
						bola.position.z - 0.05 < -tableHalfDepth) {
						ballDirection.z *= -1;
						// Pequeño sonido de rebote
						if (scene.audioEnabled) {
							const wallHitSound = new BABYLON.Sound("wallHit", "textures/metal.mp3", scene);
							wallHitSound.play();
						}
					}

					// Rebote con pala1 (todo el código de rebote existente)
					if (bola.intersectsMesh(pala1, false)) {
						// Solo invertir dirección si viene de la izquierda
						if (ballDirection.x > 0) {
							ballDirection.x *= -1;
							
							 // Ajuste de dirección según punto de impacto con más intensidad
							const deltaZ = (bola.position.z - pala1.position.z) / (pala1.scaling.z/2);
							ballDirection.z = deltaZ * 0.1;
							
							// Incrementar ligeramente la velocidad
							const currentMagnitude = Math.sqrt(
								ballDirection.x * ballDirection.x + 
								ballDirection.z * ballDirection.z
							);
							ballSpeed = Math.min(ballSpeed * 1.05, 0.035);
							const factor = ballSpeed / currentMagnitude;
							ballDirection.x *= factor;
							ballDirection.z *= factor;
							
							// Incrementar puntuación
							score += 10;
							document.getElementById('score').textContent = score;
							
							if (scene.audioEnabled) {
								const paddleHitSound = new BABYLON.Sound("paddleHit", "textures/metal.mp3", scene);
								paddleHitSound.play();
							}
						}
					}

					// Rebote con pala2 (todo el código de rebote existente)
					if (bola.intersectsMesh(pala2, false)) {
						// Solo invertir dirección si viene de la derecha
						if (ballDirection.x < 0) {
							ballDirection.x *= -1;

							// Ajuste de dirección según punto de impacto
							const deltaZ = (bola.position.z - pala2.position.z) / (pala2.scaling.z/2);
							ballDirection.z = deltaZ * 0.1;
							
							// Incrementar ligeramente la velocidad
							const currentMagnitude = Math.sqrt(
								ballDirection.x * ballDirection.x + 
								ballDirection.z * ballDirection.z
							);
							ballSpeed = Math.min(ballSpeed * 1.05, 0.035);
							const factor = ballSpeed / currentMagnitude;
							ballDirection.x *= factor;
							ballDirection.z *= factor;
							
							// Incrementar puntuación
							score += 10;
							document.getElementById('score').textContent = score;
							
							if (scene.audioEnabled) {
								const paddleHitSound = new BABYLON.Sound("paddleHit", "textures/metal.mp3", scene);
								paddleHitSound.play();
							}
						}
					}

					// Game over si se va demasiado lejos
					if (bola.position.x > 1.2) {
						gameOver("¡Punto para el jugador 2!");
					} else if (bola.position.x < -1.2) {
						gameOver("¡Punto para el jugador 1!");
					}
				});

				// Función para manejar el game over
				function gameOver(message) {
					gameActive = false;
					document.getElementById('finalScore').textContent = score;
					document.getElementById('gameOver').style.display = 'block';
					
					// Reiniciar posición de la bola para el siguiente juego
					bola.position = new BABYLON.Vector3(0, tableTop.position.y + 0.1, 0);
					ballDirection = new BABYLON.Vector3(
						Math.random() > 0.5 ? 0.02 : -0.02, 
						0, 
						(Math.random() - 0.5) * 0.01
					);
					ballSpeed = 0.02;
				}

                return scene;
            }
        }

        // Inicialización
        window.addEventListener('DOMContentLoaded', function() {
            // Crear escena y bucle
            scene = Playground.CreateScene(engine, canvas);
            startRenderLoop();

            // Botones UI
            document.getElementById('backButton').addEventListener('click', function(e) {
                e.preventDefault(); window.location.href = '/dashboard';
            });
            document.getElementById('returnToDashboardButton').addEventListener('click', function(e) {
                e.preventDefault(); window.location.href = '/dashboard';
            });
            document.getElementById('playAgainButton').addEventListener('click', function() {
                score = 0;
                document.getElementById('score').textContent = score;
                document.getElementById('gameOver').style.display = 'none';
				gameActive = true;
                scene = Playground.CreateScene(engine, canvas);
            });
            document.getElementById('saveToDashboardButton').addEventListener('click', function() {
                // Aquí podrías llamar a tu API para guardar puntuación
                console.log('Guardar puntuación:', score);
            });
            document.getElementById('resetCameraButton').addEventListener('click', function() {
                if (window.resetCamera) {
                    window.resetCamera();
                }
            });
        });
        // Redimensionar
        window.addEventListener('resize', function() {
            engine.resize();
        });
    </script>
</body>
</html>
